module Counter.Unique.Initialize;

import Stdlib.Prelude open;
import Anoma open;
import BaseLayer.ResourceMachine open;
import BaseLayer.TransactionRequest open;
import Applib.Helpers open using {mkActionHelper};
import Extra open;
import Counter.Unique.Resource open;
import Applib.Helpers open;
import Applib.Identities open;
import Anoma.State.CommitmentTree open using {mkRoot};
import Stdlib.Debug open;

import Extra.Mtl as Mtl open;
import Extra.Tx open;

initialize-old
  (randSeed : Nat)
  (consumable : Resource)
  (logic : Logic)
  (latestRoot : Nat)
  : Transaction :=
  let
    prng := mkPrng randSeed;
    (ephCounterNonce, prng') := randomNonce prng;
    (counterNonce, prng'') := randomNonce prng';
    uniqueLabel := mkUniqueCounterLabel consumable;
    ephCounter :=
      mkCounter@{
        logic;
        uniqueLabel;
        nonce := ephCounterNonce;
        count := 0;
        ephemeral := true;
      };
    newCounter :=
      mkCounter@{
        logic;
        nonce := counterNonce;
        ephemeral := false;
        uniqueLabel;
        count := 0;
      };
    ephConsumable := consumable@Resource{ephemeral := true};
    standardInputs :=
      mkStandardInputs@{
        caller := Universal.identity;
        currentRoot := mkRoot latestRoot;
        randSeed := FromNatural.fromNat randSeed;
      };
  in prepareStandardTransaction@{
       standardInputs;
       consumed := [consumable; ephCounter];
       created := [ephConsumable; newCounter];
     };

-- TODO remove randSeed from standardInputs?
initialize
  (randSeed : Nat)
  (consumable : Resource)
  (logic : Logic)
  (latestRoot : Nat)
  : Transaction :=
  let
    standardInputs :=
      mkStandardInputs@{
        caller := Universal.identity;
        currentRoot := mkRoot latestRoot;
        randSeed := FromNatural.fromNat randSeed;
      };
  in runTx
    randSeed
    standardInputs
    do {
      ephCounterNonce <- genRandomNonce;
      counterNonce <- genRandomNonce;
      let
        uniqueLabel := mkUniqueCounterLabel consumable;
        ephCounter :=
          mkCounter@{
            logic;
            uniqueLabel;
            nonce := ephCounterNonce;
            count := 0;
            ephemeral := true;
          };
        newCounter :=
          mkCounter@{
            logic;
            nonce := counterNonce;
            ephemeral := false;
            uniqueLabel;
            count := 0;
          };
        ephConsumable := consumable@Resource{ephemeral := true};
      in
      pure
        prepareStandardTransaction@{
          standardInputs;
          consumed := [consumable; ephCounter];
          created := [ephConsumable; newCounter];
        };
    };

main
  (randSeed : Nat)
  (consumable : Encoded Resource)
  (logic : Encoded Logic)
  (latestRoot : Nat)
  : TransactionRequest :=
  initialize
      randSeed
      (Encoded.decode consumable)
      (Encoded.decode logic)
      latestRoot
    |> TransactionRequest.fromTransaction;
