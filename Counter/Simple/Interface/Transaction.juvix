module Counter.Simple.Interface.Transaction;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Stdlib.Data.Set as Set open using {Set};
import Stdlib.Data.Map as Map;
import Anoma open;
import Applib.Helpers open;
import Counter.Simple.Resource open;
import Counter.Simple.Logic open;
import Counter.Simple.Count open;
import BaseLayer.TransactionRequest open;
import Anoma.State.CommitmentTree open;
import Applib.Identities as Id;

--- Initializes a counter that can be incremented by everyone.
--- @param standardInputs The transaction function standard inputs.
--- @return The transaction object initializing a counter.
initialize (standardInputs : StandardInputs) : Transaction :=
  let
    noncePair := generateNoncePair (StandardInputs.randSeed standardInputs);
  in prepareStandardTransaction@{
       standardInputs;
       consumed :=
         [
           mkCounter@{
             nonce := fst noncePair;
             ephemeral := true;
           };
         ];
       created :=
         [
           mkCounter@{
             nonce := snd noncePair;
             ephemeral := false;
           };
         ];
     };

--- Increments the counter value by 1.
--- @param currentCounter The current counter to increment.
--- @param standardInputs The transaction function standard inputs.
--- @return The transaction object incrementing a counter.
increment
  (standardInputs : StandardInputs) (currentCounter : Resource) : Transaction :=
  prepareStandardTransaction@{
    standardInputs;
    consumed := [currentCounter];
    created :=
      [
        mkCounter@{
          nonce := generateNonce (StandardInputs.randSeed standardInputs);
          count := getCount currentCounter + 1;
        };
      ];
  };

std : StandardInputs :=
  mkStandardInputs@{
    caller := Id.Universal.identity;
    currentRoot := mkRoot 0;
    randSeed := 0;
  };

tx : Transaction := initialize std;

main : TransactionRequest := TransactionRequest.fromTransaction tx;
