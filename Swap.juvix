module Swap;

import Stdlib.Prelude open;
import Stdlib.Debug.Trace open;
import Anoma.Builtin.ByteArray open;
import BaseLayer.TransactionRequest open using {
  TransactionRequest;
  module TransactionRequest;
};
import Anoma open;
import Applib.Helpers open;
import Stdlib.Debug open using {failwith};

axiom undefined {A} : A;

fromJust {A} : Maybe A -> A
  | nothing := failwith "fromJust"
  | (just x) := x;

createdMagic : Nat := anomaEncode (just true);

consumedMagic : Nat := anomaEncode "hello";

mylogic
  (publicInputs : Logic.Instance) (privateInputs : Logic.Witness) : Bool :=
  case findResource (Logic.Instance.tag publicInputs) privateInputs of
    | CreatedRes res :=
      Resource.quantity res == 1
        && Logic.Instance.appData publicInputs == createdMagic
        && Logic.Witness.customInputs privateInputs == createdMagic
    | ConsumedRes res :=
      Resource.quantity res == 1
        && Logic.Instance.appData publicInputs == consumedMagic
        && Logic.Witness.customInputs privateInputs == consumedMagic
    | NonExisting := false;

myResourceEph : Resource :=
  mkResource@{
    label := 0;
    logic := mylogic;
    ephemeral := true;
    quantity := 1;
    value := 0;
    nullifierKeyCommitment :=
      replicate 32 0x0 |> mkByteArray |> toAnomaContents;
    randSeed := 0;
    nonce := replicate 32 0x0 |> mkByteArray |> toAnomaContents;
  };

myResource : Resource :=
  mkResource@{
    label := 0;
    logic := mylogic;
    ephemeral := false;
    quantity := 1;
    value := 0;
    nullifierKeyCommitment :=
      replicate 32 0x0 |> mkByteArray |> toAnomaContents;
    randSeed := 0;
    nonce := 2;
  };

myResource' : Resource := myResource@Resource{nonce := 222};

myResourceEph' : Resource := myResourceEph@Resource{nonce := 333};

myResourceCommitment' : Nat := base-commitment myResource';

myResourceCommitment : Nat := base-commitment myResource;

myResourceEphNullifier : Nat := base-nullifier myResourceEph;

myResourceEphNullifier' : Nat := base-nullifier myResourceEph';

mycommitments : List Nat := [myResourceCommitment; myResourceCommitment'];

mynullifiers : List Nat := [myResourceEphNullifier; myResourceEphNullifier'];

mycreated : List Resource := [myResource; myResource'];

myconsumed : List Resource := [myResourceEph; myResourceEph'];

myResourceEphProof : Logic.Proof :=
  let
    publicInputs : Logic.Instance :=
      Logic.mkInstance@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        tag := myResourceEphNullifier;
        appData := consumedMagic;
      };
    privateInputs : Logic.Witness :=
      Logic.mkWitness@{
        created := mycreated;
        consumed := myconsumed;
        customInputs := consumedMagic;
      };
  in Logic.prove (Logic.mkProvingKey myResourceEph) publicInputs privateInputs;

myResourceEphProof' : Logic.Proof :=
  let
    publicInputs : Logic.Instance :=
      Logic.mkInstance@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        tag := myResourceEphNullifier';
        appData := consumedMagic;
      };
    privateInputs : Logic.Witness :=
      Logic.mkWitness@{
        created := mycreated;
        consumed := myconsumed;
        customInputs := consumedMagic;
      };
  in Logic.prove (Logic.mkProvingKey myResourceEph') publicInputs privateInputs;

myResourceProof : Logic.Proof :=
  let
    publicInputs : Logic.Instance :=
      Logic.mkInstance@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        tag := myResourceCommitment;
        appData := createdMagic;
      };
    privateInputs : Logic.Witness :=
      Logic.mkWitness@{
        created := mycreated;
        consumed := myconsumed;
        customInputs := createdMagic;
      };
  in Logic.prove (Logic.mkProvingKey myResource) publicInputs privateInputs;

myResourceProof' : Logic.Proof :=
  let
    publicInputs : Logic.Instance :=
      Logic.mkInstance@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        tag := myResourceCommitment';
        appData := createdMagic;
      };
    privateInputs : Logic.Witness :=
      Logic.mkWitness@{
        created := mycreated;
        consumed := myconsumed;
        customInputs := createdMagic;
      };
  in Logic.prove (Logic.mkProvingKey myResource') publicInputs privateInputs;

myproofs : List Logic.Proof :=
  [myResourceProof'; myResourceEphProof'; myResourceProof; myResourceEphProof];

tx-action : Action :=
  mkAction@{
    commitments := mycommitments;
    nullifiers := mynullifiers;
    proofs := myproofs;
    appData := 0;
  };

tx : Transaction :=
  mkTransaction@{
    roots := [];
    delta := actionDelta tx-action;
    actions := [tx-action];
    deltaProof := 0;
  };

main : TransactionRequest := TransactionRequest.fromTransaction tx;
