module Transaction;

import Stdlib.Prelude open;
import Anoma open;
import AnomaHelpers open;

import Intent.Asset open;
import Token.Transaction as Token open;
import Token.Error open;
import Token.Supply open;

import Label open;

initialize (self : KeyPair) (quantity : Nat) (receiver : PublicKey) 
: Result TokenError Transaction :=
  Token.initialize@{self; label := mkKudoLabel (KeyPair.pubKey self); quantity; receiver};

finalize (self : KeyPair) (token : Resource)
: Result TokenError Transaction :=
  case isKudo self token of
    | false := throw notKudoError
    | true := Token.finalize@{self; token};

send (self : KeyPair) (token : Resource) (quantity : Nat) (receiver : PublicKey)
: Result TokenError Transaction :=
  case isKudo  self token of
    | false := throw notKudoError
    | true := Token.send@{self; token; quantity; receiver};

transfer (self : KeyPair) (token : Resource) (receiver : PublicKey)
: Result TokenError Transaction  :=
  case isKudo self token of
    | false := throw notKudoError
    | true := Token.transfer@{self; token; receiver};

split (self : KeyPair) (token : Resource) (quantitiesAndReceivers : List (Pair Nat PublicKey))
: Result TokenError Transaction :=
  case isKudo self token of
    | false := throw notKudoError
    | true := Token.split@{self; token; quantitiesAndReceivers};

merge (self : KeyPair) (tokens : List Resource) (receiver : PublicKey)
: Result TokenError Transaction :=
  case all (t in tokens) {isKudo self t} of
    | false := throw notKudoError
    | true := Token.merge@{self; tokens; receiver};

swap (self : KeyPair) (token : Resource) (want : QuantifiedAssets) (solver : PublicKey)
: Result TokenError Transaction :=
  case isKudo self token of
    | false := throw notKudoError
    | true := Token.swap@{self; token; want; solver};
