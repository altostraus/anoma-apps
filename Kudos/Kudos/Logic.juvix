module Kudos.Logic;

import Anoma open;
import Kudos.Types open;
import Kudos.Extra open;
import Stdlib.Prelude open;

--- Check that the ;Transaction; is valid for the Kudo application.
--- The self argument is the ;Resource; that defines this logic function.
kudoLogic (self : Resource) (tx : Transaction) : Bool :=
  let
    rs := partitionResources tx;
    resourceKind := anomaKind self;
    isResourceKudo (r : Resource) : Bool :=
      resourceKind == anomaKind r;
    consumedKudo :=
      filter isResourceKudo (ResourcePartition.consumed rs);
    createdKudo :=
      filter isResourceKudo (ResourcePartition.created rs);
  in checkAuthorizedConsumption consumedKudo tx
    && case consumedKudo of {
         | [r] := not (Resource.eph r) || checkOriginatorOwner r
         | _ := true
       };

--- Check that the owner is the originator
checkOriginatorOwner (r : Resource) : Bool :=
  let
    ownerPubKey :=
      Owner.ownerPubKey
        (KudoValue.owner (anomaDecode (Resource.data r)));
    originatorPubKey :=
      KudoLabel.originatorPublicKey
        (anomaDecode (Resource.label r));
  in ownerPubKey == originatorPubKey;

--- Check that the owner has authorized consumption
checkAuthorizedConsumption
  (consumed : List Resource) (tx : Transaction) : Bool :=
  all (r in consumed)
    let
      value : KudoValue := anomaDecode (Resource.data r);
      ownerPubKey := Owner.ownerPubKey (KudoValue.owner value);
    in verifyOwner ownerPubKey tx;
