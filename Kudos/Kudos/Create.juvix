module Kudos.Create;

import Stdlib.Prelude open;
import Stdlib.Debug open;
import Stdlib.Data.Set as Set open using {Set};
import Stdlib.Data.Map as Map open using {Map};
import Applib open hiding {module Instance};
import Anoma.Builtin.System open;
import Anoma.Identity.External open;
import Anoma.Identity.Internal open;

type KudosPublicDataValue :=
  mkKudosPublicDataValue@{
    resourceRelationship : ResourceRelationship;
    signature : Signature;
  };

KudosPublicData : Type := Map AnomaAtom KudosPublicDataValue;

module Instance;
  import Applib open;

  open Instance using {otherPublic as otherPublic'} public;
  open Instance hiding {otherPublic} public;

  otherPublic (instance : Instance) : Encoded KudosPublicData :=
    Encode.Internal.mkEncoded (AnomaAtom.toNat (otherPublic' instance));
end;

--- A message format specifiying resources that must be created and consumed within an ;Action;.
--- @param origin The reference to the resource performing the check.
--- @param mustBeConsumed The resources that must be consumed.
--- @param mustBeCreated The resources that must be created.
type ResourceRelationship :=
  mkResourceRelationship@{
    origin : Tag;
    mustBeConsumed : List Nullifier;
    mustBeCreated : List Commitment;
  };

isValidLogic (publicInputs : Instance) (privateInputs : Witness) : Bool :=
  let
    tag := Tag.fromNat (Instance.tag publicInputs);
  in case tag of
       | Created commitment := true
       | Consumed nullifier :=
         case findResourceByNullifier (unNullifier nullifier) privateInputs of
           | nothing := false
           | just self :=
             if
               | Resource.ephemeral self :=
                 let
                   originator :=
                     builtinAnomaDecode
                       {ExternalIdentity}
                       (Resource.label self);
                 in isAuthorizedBy@{
                      signer := originator;
                      origin := tag;
                      publicInputs;
                    }
               | else :=
                 let
                   owner := builtinAnomaDecode (Resource.value self);
                 in isAuthorizedBy@{
                      signer := owner;
                      origin := tag;
                      publicInputs;
                    };

mkKudos
  (nonce : Nonce)
  (quantity : Nat)
  (originator owner : ExternalIdentity)
  (logic : Logic)
  {ephemeral : Bool := false}
  : Resource :=
  mkResource@{
    logic;
    label := builtinAnomaEncode originator;
    value := builtinAnomaEncode owner;
    quantity;
    ephemeral;
    nullifierKeyCommitment :=
      -- builtinAnomaEncode Universal.nullifierKeyCommitment;

        -- FIXME the owner should not be put here. We temporarily have it here
        -- because the indexer looks at this field at the moment.
        builtinAnomaEncode
        owner;
    nonce := Nonce.toNat nonce;
    randSeed := 0;
  };

signatureLookupKey : AnomaAtom :=
  AnomaAtom.fromNat (builtinAnomaEncode "signatureLookupKey");

isAuthorizedBy
  (signer : ExternalIdentity) (origin : Tag) (publicInputs : Instance) : Bool :=
  case
    lookupPublicInputs@{
      key := signatureLookupKey;
      publicInputs := Encode.decode (Instance.otherPublic publicInputs);
    }
  of
    | nothing := true
    | just value :=
      let
        signature := KudosPublicDataValue.signature value;
        message := KudosPublicDataValue.resourceRelationship value;
      in anomaVerifyDetached
          (Signature.unSignature signature)
          message
          (ExternalIdentity.toByteArray signer)
        && checkResourceRelationship@{
             message;
             origin;
             nullifiers :=
               Set.fromList
                 (map mkNullifier (Instance.nullifiers publicInputs));
             commitments :=
               Set.fromList
                 (map mkCommitment (Instance.commitments publicInputs));
           };

--- Checks that a ;ResourceRelationship; message has the expected values.
--- @param message The resource relationship message to check.
--- @param origin The expected origin.
--- @param nullifiers The nullifier set that must contain the `mustBeConsumed` nullifiers as a subset.
--- @param commitments The commitment set that must contain the `mustBeCreated` commitments as a subset.
--- @return The check result.
checkResourceRelationship
  (message : ResourceRelationship)
  (origin : Tag)
  (nullifiers : Set Nullifier)
  (commitments : Set Commitment)
  : Bool :=
  ResourceRelationship.origin message == origin
    && Set.isSubset
      (Set.fromList (ResourceRelationship.mustBeConsumed message))
      nullifiers
    && Set.isSubset
      (Set.fromList (ResourceRelationship.mustBeCreated message))
      commitments;

lookupPublicInputs
  (key : AnomaAtom)
  (publicInputs : KudosPublicData)
  : Maybe KudosPublicDataValue := Map.lookup key publicInputs;

actionWithAuthorizationAppData
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (created : List Resource)
  (consumed : List Resource)
  : M Action :=
  do {

    caller <- TxContext.caller <$> getTxContext;
    let
      nullifiers := map nullifier consumed;
      commitments := map commitment created;

      -- Put signed messages and signatures by the owner in the app data.
      -- The signed messages link back to the original consumed resources,
      -- where the signature verification is part of the resource logic
      -- requiring the commitments of created resources to be part of the
      -- action.
      appDataMap : Map Nat KudosPublicData :=
        map (nullifier in nullifiers) {
            let
              nestedMap : KudosPublicData :=
                Map.singleton
                  signatureLookupKey
                  mkResourceRelationshipAppDataEntry@{
                    signer := Identity.internal caller;
                    origin := Consumed (mkNullifier nullifier);
                    mustBeConsumed := [];
                    mustBeCreated := map mkCommitment commitments;
                  };
            in nullifier, nestedMap
          }
          |> Map.fromList;
      map' : Map Nat AnomaAtom :=
        map (builtinAnomaEncode >> AnomaAtom.fromNat) appDataMap;
      appData : AppData := map' |> AppData.fromMap;

    in
    pure
      mkActionHelper@{
        consumed;
        created;
        appData;
      };
  };

builtinAnomaEncodeAtom {A} : A -> AnomaAtom :=
  builtinAnomaEncode >> AnomaAtom.fromNat;

mkResourceRelationshipAppDataEntry
  (signer : InternalIdentity)
  (origin : Tag)
  (mustBeConsumed : List Nullifier)
  (mustBeCreated : List Commitment)
  : KudosPublicDataValue :=
  let
    resourceRelationship : ResourceRelationship :=
      mkResourceRelationship@{
        origin;
        mustBeConsumed;
        mustBeCreated;
      };
    signature : Signature :=
      sign@{
        message := resourceRelationship;
        signer;
      };
  in mkKudosPublicDataValue@{
       resourceRelationship;
       signature;
     };

initialize
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (quantity : Nat)
  (logic : Logic)
  : M Transaction :=
  do {
    ctx <- getTxContext;
    nonce <- genRandomNonce;
    let
      caller : ExternalIdentity := Identity.external (TxContext.caller ctx);

      toInitialize : Resource :=
        mkKudos@{
          nonce;
          quantity;
          originator := caller;
          owner := caller;
          logic;
        };

      toConsumeEph : Resource :=
        toInitialize@Resource{
          ephemeral := true;
          -- TODO this needs to agree with what the indexer function for owners does.
          nullifierKeyCommitment := ExternalIdentity.toNat caller;
        };
    in
    action <- actionWithAuthorizationAppData@{
                consumed := [toConsumeEph];
                created := [toInitialize];
              };
    let
      tokenCreationTransaction :=
        mkTransactionHelper@{
          roots := [TxContext.currentRoot ctx];
          actions := [action];
        };
    in
    pure tokenCreationTransaction;
  };

txContext (caller : Identity) (latestRoot : Nat) : TxContext :=
  mkTxContext@{
    caller;
    currentRoot := mkRoot latestRoot;
  };

mkIdentityFromPayload (privateKey publicKey : Nat) : Identity :=
  mkIdentity@{
    internal :=
      InternalIdentity.fromByteArray (fromAnomaContents 64 privateKey);
    external := ExternalIdentity.fromByteArray (fromAnomaContents 32 publicKey);
  };

main
  (privateKeyPayload publicKeyPayload : Nat)
  (rngSeed : Nat)
  (logic : Logic)
  (quantity : Nat)
  : TransactionRequest :=
  let
    caller : Identity := mkIdentityFromPayload privateKeyPayload publicKeyPayload;
  in buildTransactionRequest
    rngSeed
    (txContext caller 0)
    (initialize quantity logic);
