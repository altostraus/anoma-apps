module Kudos.Create;

import Stdlib.Prelude open;
import Stdlib.Data.Set as Set open using {Set};
import Stdlib.Data.Map as Map open using {Map};
import Applib open;
import Anoma.Builtin.System open;
import Anoma.Identity.External open;

--- A message format specifiying resources that must be created and consumed within an ;Action;.
--- @param origin The reference to the resource performing the check.
--- @param mustBeConsumed The resources that must be consumed.
--- @param mustBeCreated The resources that must be created.
type ResourceRelationship :=
  mkResourceRelationship@{
    origin : Tag;
    mustBeConsumed : Set Nullifier;
    mustBeCreated : Set Commitment;
  };

isValidLogic (publicInputs : Instance) (privateInputs : Witness) : Bool :=
  let
    tag := Tag.fromNat (Instance.tag publicInputs);
    customInputs := Witness.customInputs privateInputs;
  in case tag of
    | Consumed nullifier :=
      case findResourceByNullifier (unNullifier nullifier) privateInputs of {
        | nothing := false
        | just self :=
          if
            | Resource.ephemeral self :=
              let
                originator := Resource.label self;
              in isAuthorizedBy@{
                   signer := builtinAnomaDecode originator;
                   origin := tag;
                   publicInputs;
                 }
            | else :=
              let
                owner := Resource.value self;
              in isAuthorizedBy@{
                   signer := builtinAnomaDecode owner;
                   origin := tag;
                   publicInputs;
                 }
      }
    | Created commitment :=
      case findResourceByCommitment (unCommitment commitment) privateInputs of {
        | nothing := false
        | just self :=
          if
            | Resource.ephemeral self := todo
            | else := true
      };

create
  (nonce : Nonce)
  (quantity : Nat)
  (originator owner : ExternalIdentity)
  (logic : Logic)
  {ephemeral : Bool := false}
  : Resource :=
  mkResource@{
    logic;
    label := builtinAnomaEncode originator;
    value := builtinAnomaEncode owner;
    quantity;
    ephemeral;
    nullifierKeyCommitment :=
      builtinAnomaEncode Universal.nullifierKeyCommitment;
    nonce := Nonce.toNat nonce;
    randSeed := 0;
  };

isAuthorizedBy
  (signer : ExternalIdentity)
  (origin : Tag)
  (publicInputs : Instance)
  : Bool :=
  case
    lookupAppData@{
      key := origin;
      Value := Pair ResourceRelationship Signature;
      appData := Instance.appData publicInputs;
    }
  of
    | nothing := false
    | just (message, signature) :=
      (anomaVerifyDetached
        (Signature.unSignature signature)
        message
        (ExternalIdentity.unExternalIdentity signer))
        && checkResourceRelationship@{
             message;
             origin;
             nullifiers := Set.fromList (map mkNullifier (Instance.nullifiers publicInputs));
             commitments := Set.fromList (map mkCommitment (Instance.commitments publicInputs));
           };


--- Checks that a ;ResourceRelationship; message has the expected values.
--- @param message The resource relationship message to check.
--- @param origin The expected origin.
--- @param nullifiers The nullifier set that must contain the `mustBeConsumed` nullifiers as a subset.
--- @param commitments The commitment set that must contain the `mustBeCreated` commitments as a subset.
--- @return The check result.
checkResourceRelationship
  (message : ResourceRelationship)
  (origin : Tag)
  (nullifiers : Set Nullifier)
  (commitments : Set Commitment)
  : Bool :=
  ResourceRelationship.origin message == origin
    && Set.isSubset (ResourceRelationship.mustBeConsumed message) nullifiers
    && Set.isSubset (ResourceRelationship.mustBeCreated message) commitments;

lookupAppData
  {Key Value : Type} (key : Key) (appData : AppData) : Maybe Value :=
  case Map.lookup (builtinAnomaEncode key) (AppData.toMap appData) of
    | nothing := nothing
    | just value := just (value |> AnomaAtom.toNat |> builtinAnomaDecode);
