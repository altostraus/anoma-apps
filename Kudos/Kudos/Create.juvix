module Kudos.Create;

import Stdlib.Prelude open;
import Stdlib.Debug open;
import Stdlib.Data.Set as Set open using {Set};
import Stdlib.Data.Map as Map open using {Map};
import Applib open;
import Anoma.Builtin.System open;
import Anoma.Identity.External open;

--- A message format specifiying resources that must be created and consumed within an ;Action;.
--- @param origin The reference to the resource performing the check.
--- @param mustBeConsumed The resources that must be consumed.
--- @param mustBeCreated The resources that must be created.
type ResourceRelationship :=
  mkResourceRelationship@{
    origin : Tag;
    mustBeConsumed : List Nullifier;
    mustBeCreated : List Commitment;
  };

isValidLogic (publicInputs : Instance) (privateInputs : Witness) : Bool :=
  let
    tag := Tag.fromNat (Instance.tag publicInputs);
  in case tag of
       | Created commitment := true
       | Consumed nullifier :=
         case findResourceByNullifier (unNullifier nullifier) privateInputs of
           | nothing := false
           | just self :=
             if
               | Resource.ephemeral self :=
                 let
                   originator := builtinAnomaDecode (Resource.label self);
                 in isAuthorizedBy@{
                      signer := originator;
                      origin := tag;
                      publicInputs;
                    }
               | else :=
                 let
                   owner := builtinAnomaDecode (Resource.value self);
                 in isAuthorizedBy@{
                      signer := owner;
                      origin := tag;
                      publicInputs;
                    };

create
  (nonce : Nonce)
  (quantity : Nat)
  (originator owner : ExternalIdentity)
  (logic : Logic)
  {ephemeral : Bool := false}
  : Resource :=
  mkResource@{
    logic;
    label := builtinAnomaEncode originator;
    value := builtinAnomaEncode owner;
    quantity;
    ephemeral;
    nullifierKeyCommitment :=
      -- builtinAnomaEncode Universal.nullifierKeyCommitment;

        -- FIXME the owner should not be put here. We temporarily have it here
        -- because the indexer looks at this field at the moment.
        builtinAnomaEncode
        owner;
    nonce := Nonce.toNat nonce;
    randSeed := 0;
  };

signatureLookupKey : AnomaAtom :=
  AnomaAtom.fromNat (builtinAnomaEncode "signatureLookupKey");

isAuthorizedBy
  (signer : ExternalIdentity) (origin : Tag) (publicInputs : Instance) : Bool :=
  case
    lookupAppData@{
      key := signatureLookupKey;
      Value := Pair ResourceRelationship Signature;
      appData :=
        builtinAnomaDecode
          (AnomaAtom.toNat (Instance.otherPublic publicInputs));
    }
  of
    | nothing := false
    | just (message, signature) :=
      anomaVerifyDetached
          (Signature.unSignature signature)
          message
          (ExternalIdentity.toByteArray signer)
        && checkResourceRelationship@{
             message;
             origin;
             nullifiers :=
               Set.fromList
                 (map mkNullifier (Instance.nullifiers publicInputs));
             commitments :=
               Set.fromList
                 (map mkCommitment (Instance.commitments publicInputs));
           };

--- Checks that a ;ResourceRelationship; message has the expected values.
--- @param message The resource relationship message to check.
--- @param origin The expected origin.
--- @param nullifiers The nullifier set that must contain the `mustBeConsumed` nullifiers as a subset.
--- @param commitments The commitment set that must contain the `mustBeCreated` commitments as a subset.
--- @return The check result.
checkResourceRelationship
  (message : ResourceRelationship)
  (origin : Tag)
  (nullifiers : Set Nullifier)
  (commitments : Set Commitment)
  : Bool :=
  ResourceRelationship.origin message == origin
    && Set.isSubset
      (Set.fromList (ResourceRelationship.mustBeConsumed message))
      nullifiers
    && Set.isSubset
      (Set.fromList (ResourceRelationship.mustBeCreated message))
      commitments;

lookupAppData
  {Key Value : Type} (key : Key) (appData : AppData) : Maybe Value :=
  case Map.lookup (builtinAnomaEncode key) (AppData.toMap appData) of
    | nothing := nothing
    | just value := just (value |> AnomaAtom.toNat |> builtinAnomaDecode);

actionWithAuthorizationAppData
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (created : List Resource)
  (consumed : List Resource)
  : M Action :=
  do {

    caller <- TxContext.caller <$> getTxContext;
    let
      nullifiers := map nullifier consumed;
      commitments := map commitment created;

      -- Put signed messages and signatures by the owner in the app data.
      -- The signed messages link back to the original consumed resources,
      -- where the signature verification is part of the resource logic
      -- requiring the commitments of created resources to be part of the
      -- action.
      appDataMap
        : Map Nat (Map AnomaAtom (Pair ResourceRelationship Signature)) :=
        map (nullifier in nullifiers) {
            let
              nestedMap : Map AnomaAtom (Pair ResourceRelationship Signature) :=
                Map.singleton
                  signatureLookupKey
                  mkResourceRelationshipAppDataEntry@{
                    signer := Identity.internal caller;
                    origin := Consumed (mkNullifier nullifier);
                    mustBeConsumed := [];
                    mustBeCreated := map mkCommitment commitments;
                  };
            in nullifier, nestedMap
          }
          |> Map.fromList;
      map' : Map Nat AnomaAtom :=
        map (builtinAnomaEncode >> AnomaAtom.fromNat) appDataMap;
      appData : AppData := map' |> AppData.fromMap;

    in
    pure
      mkActionHelper@{
        consumed;
        created;
        appData;
      };
  };

builtinAnomaEncodeAtom {A} : A -> AnomaAtom :=
  builtinAnomaEncode >> AnomaAtom.fromNat;

mkResourceRelationshipAppDataEntry
  (signer : InternalIdentity)
  (origin : Tag)
  (mustBeConsumed : List Nullifier)
  (mustBeCreated : List Commitment)
  : Pair ResourceRelationship Signature :=
  let
    message : ResourceRelationship :=
      mkResourceRelationship@{
        origin;
        mustBeConsumed;
        mustBeCreated;
      };
    signature : Signature :=
      sign@{
        message;
        signer;
      };
  in message, signature;

initialize
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (toInitialize : Resource)
  : M Transaction :=
  do {
    ctx <- getTxContext;
    nonce <- Nonce.toNat <$> genRandomNonce;
    let
      self : ExternalIdentity := Identity.external (TxContext.caller ctx);

      toConsumeEph : Resource :=
        toInitialize
          |> \{r :=
            r@Resource{
              ephemeral := true;
              -- TODO this needs to agree with what the indexer function for owners does.
              nullifierKeyCommitment := ExternalIdentity.toNat self;
              nonce;
            }};
    in
    action <- actionWithAuthorizationAppData@{
                consumed := [toConsumeEph];
                created := [toInitialize];
              };
    let
      tokenCreationTransaction :=
        mkTransactionHelper@{
          roots := [TxContext.currentRoot ctx];
          actions := [action];
        };
    in
    pure tokenCreationTransaction;
  };
