module Kudos.Transfer;

import Stdlib.Prelude open;
import Stdlib.Debug open;
import Stdlib.Data.Set as Set open using {Set};
import Stdlib.Data.Map as Map open using {Map};
import Applib open;
import Anoma.Builtin.System open;
import Anoma.Identity.External open;
import Anoma.Identity.Internal open;
import Kudos.Layer open;

computeKind (logic : Logic) (label : Nat) : Kind :=
  let
    dummy : Resource :=
      mkResource@{
        label;
        logic;
        -- the arguments below don't matter
        ephemeral := true;
        nonce := 0;
        value := 0;
        quantity := 0;
        randSeed := 0;
        nullifierKeyCommitment := 0;
      };
  in kind dummy;

transfer
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (kudosLogic : Logic)
  (token : Resource)
  (receiver : ExternalIdentity)
  : M Transaction :=
  do {
    caller <- TxContext.caller <$> getTxContext;
    let
      self := Identity.external caller;
    in
    case isKudo kudosLogic token of {
      | false := failwith "not kudos"
      | true :=
        transferHelper@{
          toTransfer := token;
          receiver;
        }
    };
  };

isKudo (kudosLogic : Logic) (resource : Resource) : Bool :=
  computeKind kudosLogic (Resource.label resource) == kind resource;

transferHelper
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (toTransfer : Resource)
  (receiver : ExternalIdentity)
  : M Transaction :=
  do {
    txCtx <- getTxContext;
    nonce <- genRandomNonce;
    let
      caller := Identity.external (TxContext.caller txCtx);
      currentRoot := TxContext.currentRoot txCtx;
      owner : ExternalIdentity := Kudos.Resource.owner toTransfer;
      transferred : Resource :=
        toTransfer
          |> Kudos.Resource.setOwner receiver
          |> (@Resource{nonce := Nonce.toNat nonce});
    in
    pure
      mkTransactionHelper@{
        roots := [currentRoot];
        actions :=
          [
            mkActionHelper@{
              consumed := [toTransfer];
              created := [transferred];
            };
          ];
      };
  };

txContext (caller : Identity) (latestRoot : Nat) : TxContext :=
  mkTxContext@{
    caller;
    currentRoot := mkRoot latestRoot;
  };

main
  (latestRoot : Nat)
  (randSeed : Nat)
  (receiver : Nat)
  (r : Resource)
  (logic : Logic)
  : TransactionRequest :=
  let
    receiverIden : ExternalIdentity :=
      ExternalIdentity.fromByteArray (fromAnomaContents 32 receiver);
    callerIdentity : Identity :=
      mkIdentity@{
        external := Kudos.Resource.owner r;
        -- the internal identity is not required, so we give a dummy value
        internal := Universal.internalIdentity;
      };
  in buildTransactionRequest
    randSeed
    (txContext callerIdentity latestRoot)
    (transfer logic r receiverIden);
