module Kudos.Layer;

import Kudos.Extra open;
import Stdlib.Prelude open;
import Stdlib.Data.Set as Set open using {Set};
import Stdlib.Data.Map as Map open using {Map};
import Stdlib.Debug open;
import Applib open;
import Anoma.Builtin.System open;
import Anoma.Identity.External open;
import Anoma.Identity.Internal open;

signatureLookupKey : AnomaAtom :=
  AnomaAtom.fromNat (builtinAnomaEncode "signatureLookupKey");

mkIdentityFromPayload (privateKey publicKey : ByteArray) : Identity :=
  mkIdentity@{
    internal :=
      InternalIdentity.fromByteArray privateKey;
    external := ExternalIdentity.fromByteArray publicKey;
  };

actionWithAuthorizationAppData
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (created : List Resource)
  (consumed : List Resource)
  : M Action :=
  do {
    caller <- TxContext.caller <$> getTxContext;
    let
      nullifiers := map nullifier consumed;
      commitments := map commitment created;

      -- Put signed messages and signatures by the owner in the app data.
      -- The signed messages link back to the original consumed resources,
      -- where the signature verification is part of the resource logic
      -- requiring the commitments of created resources to be part of the
      -- action.
      appDataMap : Map Nat Kudos.PublicData :=
        (map (n in nullifiers) {
              let
                nestedMap : Kudos.PublicData :=
                  Map.singleton
                    signatureLookupKey
                    mkResourceRelationshipAppDataEntry@{
                      signer := Identity.internal caller;
                      origin := Consumed (mkNullifier n);
                      mustBeConsumed := [];
                      mustBeCreated := map mkCommitment commitments;
                    };
              in n, nestedMap
            }
            ++ map (c in commitments) {
              let
                nestedMap : Kudos.PublicData := Map.empty;
              in c, nestedMap
            })
          |> Map.fromList;
      map' : Map Nat AnomaAtom :=
        map (builtinAnomaEncode >> AnomaAtom.fromNat) appDataMap;
    in
    pure
      mkActionHelper@{
        consumed;
        created;
        appData := AppData.fromMap map';
      };
  };


mkResourceRelationshipAppDataEntry
  (signer : InternalIdentity)
  (origin : Tag)
  (mustBeConsumed : List Nullifier)
  (mustBeCreated : List Commitment)
  : Kudos.PublicDataValue :=
  let
    resourceRelationship : ResourceRelationship :=
      mkResourceRelationship@{
        origin;
        mustBeConsumed;
        mustBeCreated;
      };
    signature : Signature :=
      sign@{
        message := resourceRelationship;
        signer;
      };
  in Kudos.mkPublicDataValue@{
       resourceRelationship;
       signature;
     };

module Kudos;

  PublicData : Type := Map AnomaAtom PublicDataValue;

  type PublicDataValue :=
    mkPublicDataValue@{
      resourceRelationship : ResourceRelationship;
      signature : Signature;
    };

  module Instance;
    otherPublic (instance : Instance) : Kudos.PublicData :=
      builtinAnomaDecode
        (AnomaAtom.toNat (Applib.Instance.otherPublic instance));
  end;

  module Resource;
    identity (r : Resource) : Kudos.Identity :=
      builtinAnomaDecode (Applib.Resource.label r);

    owner (r : Resource) : ExternalIdentity :=
      ExternalIdentity.fromByteArray
        (fromAnomaContents 32 (Applib.Resource.nullifierKeyCommitment r));

    setOwner (newOwner : ExternalIdentity) (r : Resource) : Resource :=
      Applib.mkResource@{
        logic := Applib.Resource.logic r;
        ephemeral := Applib.Resource.ephemeral r;
        quantity := Applib.Resource.quantity r;
        nonce := Applib.Resource.nonce r;
        randSeed := Applib.Resource.randSeed r;
        value := Applib.Resource.value r;
        nullifierKeyCommitment :=
          toAnomaContents (ExternalIdentity.toByteArray newOwner);
        label := Applib.Resource.label r;
      };

    -- TODO investigate bug with default arguments
    updateResource
      (r : Resource)
      {logic : Logic := Applib.Resource.logic r}
      {ephemeral : Bool := Applib.Resource.ephemeral r}
      {quantity : Nat := Applib.Resource.quantity r}
      {value : Nat := Applib.Resource.value r}
      {nonce : Nonce := Nonce.fromNat (Applib.Resource.nonce r)}
      (kudosSymbol : String)
      (owner : ExternalIdentity)
      (originator : ExternalIdentity)
      : Resource :=
      mkResource@{
        logic;
        ephemeral;
        quantity;
        nonce;
        value;
        originator;
        owner;
        kudosSymbol;
      };

    mkResource
      (logic : Logic)
      (ephemeral : Bool)
      (quantity : Nat)
      (value : Nat)
      (originator owner : ExternalIdentity)
      (kudosSymbol : String)
      (nonce : Nonce)
      : Resource :=
      Applib.mkResource@{
        logic;
        ephemeral;
        quantity;
        nonce := Nonce.toNat nonce;
        randSeed := 0;
        value := 0;
        nullifierKeyCommitment :=
          -- FIXME the owner should not be put here. We temporarily have it here
            -- because the indexer looks at this field at the moment.
            toAnomaContents
            (ExternalIdentity.toByteArray owner);
        label :=
          builtinAnomaEncode
            Kudos.mkIdentity@{
              originator;
              kudosSymbol;
            };
      };
  end;

  open Resource using {mkResource} public;

  type Identity :=
    mkIdentity@{
      originator : ExternalIdentity;
      --- E.g. '‚Ç¨' 'üêÇ' 'üôÄ'
      kudosSymbol : String;
    };
end;
