module Extra.Mtl.StateT;

import Stdlib.Prelude open;

type StateT (S : Type) (M : Type → Type) (A : Type) :=
  mkStateT {runStateT : S → M (Pair A S)};

runState
  {S A : Type}
  {M : Type → Type}
  (s : S)
  (m : StateT S M A)
  : M (Pair A S) := StateT.runStateT m s;

evalState
  {S A : Type}
  {M : Type → Type}
  {{Functor M}}
  (s : S)
  (m : StateT S M A)
  : M A := Functor.map fst (runState s m);

instance
StateT-Functor
  {S : Type}
  {M : Type → Type}
  {{func : Functor M}}
  : Functor (StateT S M) :=
  mkFunctor@{
    map {A B : Type} (f : A → B) : StateT S M A → StateT S M B
      | (mkStateT S→M⟨A×S⟩) :=
        mkStateT
          λ {s := Functor.map λ {(a, s') := f a, s'}  (S→M⟨A×S⟩ s)}
  };

instance
StateT-Applicative {S : Type} {M : Type -> Type} : Applicative (StateT S M) :=
  mkApplicative@{
    ap {A B} : StateT S M (A -> B) -> StateT S M A -> StateT S M B
      | (mkStateT mf) (mkStateT mx) := mkStateT \{ s :=
       let (f, s') := mf s
       in
      mx };
    pure {A : Type} (a : A) : StateT S M A :=
      mkStateT λ {s := Applicative.pure (a, s)};
      };

instance
StateT-Monad
  {S : Type}
  {M : Type → Type}
  {{mon : Monad M}}
  : Monad (StateT S M) :=
  mkMonad@{
    applicative :=
      StateT-Functor@{
        func := Applicative.functor
      };
    bind
      {A B : Type}
      (x : StateT S M A)
      (f : A → StateT S M B)
      : StateT S M B :=
      mkStateT
        λ {s :=
          StateT.runStateT x s
            Monad.bind λ {(a, s') := StateT.runStateT (f a) s'}}
  };

import Extra.Mtl.MonadState open;

instance
StateT-MonadState
  {S : Type}
  {M : Type → Type}
  {{Monad M}}
  : MonadState S (StateT S M) :=
  mkMonadState@{
    monad := StateT-Monad;
    get : StateT S M S :=
      mkStateT λ {s := Applicative.pure (s, s)};
    put (s : S) : StateT S M Unit :=
      mkStateT λ {_ := Applicative.pure (unit, s)}
  };
